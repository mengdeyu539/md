<center> <h1>第 3 章索引 </h1></center>



```python
import numpy as np
import pandas as pd
```

## 1. インデックス器
### 1. テーブルの列索引
カラムインデックスは最も一般的なインデックス形式であり、一般的には `[]` によって実装されます。 `[列名]` を使用して、 `DataFrame` から対応する列を取り出すことができます。戻り値は `Series` です。たとえば、テーブルから名前の列を取り出します：



```python
df = pd.read_csv('../data/learn_pandas.csv', usecols = ['School', 'Grade', 'Name', 'Gender', 'Weight', 'Transfer'])
df['Name'].head()
```




    0      Gaopeng Yang1    Changqiang You2           Mei Sun3      Xiaojuan Sun4       Gaojuan YouName: Name, dtype: object



複数の列を取り出す場合は、テーブルから性別と名前の2列を取り出すように、 `[列名组成的列表]` を返す `DataFrame` を使用します：



```python
df[['Gender', 'Name']].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Gender</th>
      <th>Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Female</td>
      <td>Gaopeng Yang</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Male</td>
      <td>Changqiang You</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Male</td>
      <td>Mei Sun</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Female</td>
      <td>Xiaojuan Sun</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Male</td>
      <td>Gaojuan You</td>
    </tr>
  </tbody>
</table>
</div>



また、カラム名にスペースを含まない単一の列を取り出すには、 `.列名` を使用して取り出すことができます。これは `[列名]` と同等です：



```python
df.Name.head()
```




    0      Gaopeng Yang1    Changqiang You2           Mei Sun3      Xiaojuan Sun4       Gaojuan YouName: Name, dtype: object



### 2. シーケンスの行索引

[a] 文字列でインデックスされた `Series`

単一のインデックスに対応する要素を取り出す場合は、 `[item]`、 `Series` が単一の値のみに対応する場合は、このスカラー値を返し、複数の値が対応する場合は1つの `Series` を返すことができます。



```python
s = pd.Series([1, 2, 3, 4, 5, 6], index=['a', 'b', 'a', 'a', 'a', 'c'])
s['a']
```




    a    1a    3a    4a    5dtype: int64





```python
s['b']
```




    2



複数のインデックスから対応する要素を取り出す場合は、 `[items的列表]` を使用できます：



```python
s[['c', 'b']]
```




    c    6b    2dtype: int64



2つのインデックスの間の要素を取り出したい場合、この2つのインデックスがインデックス全体で唯一存在する場合は、スライスを使用できます。スライスには2つのエンドポイントが含まれていることに注意してください。



```python
s['c': 'b': -2]
```




    c    6a    4b    2dtype: int64



前後のエンドポイントの値が繰り返される場合は、スライスを使用するにはソートする必要があります：



```python
try:
    s['a': 'b']
except Exception as e:
    Err_Msg = e
Err_Msg
```




    KeyError("Cannot get left slice bound for non-unique label: 'a'")





```python
s.sort_index()['a': 'b']
```




    a    1a    3a    4a    5b    2dtype: int64



[b] 整数指標の `Series`

データの読み込み関数を使用する場合、対応するカラムをインデックスとして特に指定しない場合、0から始まる整数インデックスがデフォルトインデックスとして生成されます。もちろん、長さの要件を満たす任意の整数のセットをインデックスとすることができます。

文字列と同様に、 `[int]` または `[int_list]` を使用すると、インデックス**要素**の値を取り出すことができます。



```python
s = pd.Series(['a', 'b', 'c', 'd', 'e', 'f'], index=[1, 3, 1, 2, 5, 4])
s[1]
```




    1    a1    cdtype: object





```python
s[[2,3]]
```




    2    d3    bdtype: object



整数スライスを使用する場合、インデックス**位置**に対応する値が取り出されます。ここの整数スライスは、 `Python` のスライスと同様に右端点を含まないことに注意してください。



```python
s[1:-1:2]
```




    3    b2    ddtype: object



#### [WARNING] インデックスタイプについての說明

トラブルに巻き込まれたくない場合は、純粋な浮動小数点や混合型（文字列、整数、浮動小数点型などの混合）をインデックスにしないでください。そうしないと、特定の操作でエラーが発生したり、予期しない結果が返されたりする可能性があり、実際のデータ分析ではそうする動機はありません。

#### [END]

### 3. locインデックス

 `DataFrame` の列の選択について說明しましたが、次はその行の選択について說明します。テーブルには、2種類のインデックスがあります。1つは**要素**ベースの `loc` インデックスと、もう1つは**位置**ベースの `iloc` インデックスです。

 `loc` インデックスの一般的な形式は `loc[*, *]` で、最初の `*` は行の選択を表し、2番目の `*` は列の選択を表し、2番目の位置を省略して `loc[*]` と書くと、この `*` は行のフィルタリングを指します。このうち、 `*` の位置には、単一要素、要素リスト、要素スライス、ブールリスト、関数の5種類の合法的なオブジェクトがあります。以下で順に説明します。

その操作を実証するために、まず `set_index` メソッドを使用して `Name` 列をインデックスにします。この関数の他の使用方法については、マルチレベルインデックスの章で説明します。



```python
df_demo = df.set_index('Name')
df_demo.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



[a] `*` は単一の要素

このとき、対応する行または列を直接取り出し、その要素がインデックス内で繰り返されている場合は `DataFrame`、そうでない場合は `Series` になります：



```python
df_demo.loc['Qiang Sun'] # 多个人叫此名字
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>53.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Sophomore</td>
      <td>Female</td>
      <td>40.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_demo.loc['Quan Zhao'] # 名字唯一
```




    School      Shanghai Jiao Tong UniversityGrade                              JuniorGender                             FemaleWeight                               53.0Transfer                                NName: Quan Zhao, dtype: object



行と列の両方を選択することもできます：



```python
df_demo.loc['Qiang Sun', 'School'] # 返回Series
```




    NameQiang Sun              Tsinghua UniversityQiang Sun              Tsinghua UniversityQiang Sun    Shanghai Jiao Tong UniversityName: School, dtype: object





```python
df_demo.loc['Quan Zhao', 'School'] # 返回单个元素
```




    'Shanghai Jiao Tong University'



[b] `*` は要素リスト

このとき、リスト内のすべての要素値に対応する行または列を取り出します：



```python
df_demo.loc[['Qiang Sun','Quan Zhao'], ['School','Gender']]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Gender</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Quan Zhao</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Female</td>
    </tr>
  </tbody>
</table>
</div>



[c] `*` スライス用

以前の `Series` 文字列インデックスを使用したときに述べたように、一意の値の始点と終点文字であれば、スライスを使用でき、2つの終点を含み、一意でない場合はエラーが報告されます：



```python
df_demo.loc['Gaojuan You':'Gaoqiang Qian', 'School':'Gender']
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Gaoqiang Qian</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
    </tr>
  </tbody>
</table>
</div>



 `DataFrame` が整数インデックスを使用している場合、整数スライスを使用する場合は、上記の文字列インデックスの要求と一致しており、いずれも**要素**スライスであり、終点を含み、始点と終点の重複値は許可されていないことに注意してください。



```python
df_loc_slice_demo = df_demo.copy()
df_loc_slice_demo.index = range(df_demo.shape[0],0,-1)
df_loc_slice_demo.loc[5:3]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>5</th>
      <td>Fudan University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Female</td>
      <td>45.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_loc_slice_demo.loc[3:5] # 没有返回，说明不是整数位置切片
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>



 `*` はブールリスト

実際のデータ処理では、条件に基づいて行をフィルタリングすることが非常に一般的であり、ここで `loc` のブールリストが `DataFrame` と同じ長さで、リストが `True` の位置に対応する行は選択され、 `False` は削除されます。

たとえば、体重が70kg以上の学生を選択します。



```python
df_demo.loc[df_demo.Weight>70].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaopeng Zhou</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaofeng Sun</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>71.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Zheng</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



前に述べた受信要素のリストは、 `isin` メソッドによって返されるブールリストと同等に書くこともできます。たとえば、大学1年生と大学4年生のすべてのクラスメート情報を選択します：



```python
df_demo.loc[df_demo.Grade.isin(['Freshman', 'Senior'])].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>51.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



複合条件の場合、 `|（或）, &（且）, ~（取反）` の組み合わせで実現することができます。例えば、復旦大学の体重が70kgを超える大学4年生や、北京大学の男子学生の体重が80kgを超える大学4年生以外の学生を選ぶことができます：



```python
condition_1_1 = df_demo.School == 'Fudan University'
condition_1_2 = df_demo.Grade == 'Senior'
condition_1_3 = df_demo.Weight > 70
condition_1 = condition_1_1 & condition_1_2 & condition_1_3
condition_2_1 = df_demo.School == 'Peking University'
condition_2_2 = df_demo.Grade == 'Senior'
condition_2_3 = df_demo.Weight > 80
condition_2 = condition_2_1 & (~condition_2_2) & condition_2_3
df_demo.loc[condition_1 | condition_2]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Han</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Zhou</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changpeng Zhao</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>83.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Qian</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



#### [練習して練習する]

 `select_dtypes` はテーブルから適切なタイプの列を選択することができるユーティリティ関数です。すべての数値型の列を選択するには、 `.select_dtypes('number')` を使用するだけです。この機能を `DataFrame` の `dtypes` 属性と組み合わせて `learn_pandas` データセットに実装します。

#### [END]

[e] `*` 関数として

ここでの関数は、前の4つの正当な形式のいずれかを戻り値とし、関数の入力値は `DataFrame` 自体でなければなりません。上記の複合条件フィルタの例であると仮定して、論理を関数に書き込んで戻すことができます。関数の形式引数 `x` は本質的に `df_demo` であることに注意してください：



```python
def condition(x):
    condition_1_1 = x.School == 'Fudan University'
    condition_1_2 = x.Grade == 'Senior'
    condition_1_3 = x.Weight > 70
    condition_1 = condition_1_1 & condition_1_2 & condition_1_3
    condition_2_1 = x.School == 'Peking University'
    condition_2_2 = x.Grade == 'Senior'
    condition_2_3 = x.Weight > 80
    condition_2 = condition_2_1 & (~condition_2_2) & condition_2_3
    result = condition_1 | condition_2
    return result
df_demo.loc[condition]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Han</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Zhou</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changpeng Zhao</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>83.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Qian</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



また、 `lambda` 式の使用もサポートされており、戻り値は前述の4つの形式のいずれかである必要があります：



```python
df_demo.loc[lambda x:'Quan Zhao', lambda x:'Gender']
```




    'Female'



関数は `start: end: step` のようなスライスを返すことができないので、スライスを返すときに `slice` オブジェクトでラッピングします。



```python
df_demo.loc[lambda x: slice('Gaojuan You', 'Gaoqiang Qian')]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>51.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaoqiang Qian</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



最後に、 `Series` に対しても `loc` インデックスを使用することができます。これは、 `DataFrame` で行フィルタリングに使用されている `loc[*]` と完全に同じ原則に従います。ここでは説明しないでください。

#### [WARNING] チェーン割り当てを使用しないでください

テーブルまたはシーケンスに値を割り当てるときは、インデックスレイヤを使用した後に直接値を割り当てる必要があります。これは、複数のインデックスを実行した後、一時的に返された `copy` コピーに値を割り当てるので、要素を実際に変更して `SettingWithCopyWarning` 警告を報告することはありません。たとえば、以下の例を示します：



```python
df_chain = pd.DataFrame([[0,0],[1,0],[-1,0]], columns=list('AB'))
df_chain
import warnings
with warnings.catch_warnings():
    warnings.filterwarnings('error')
    try:
        df_chain[df_chain.A!=0].B = 1 # 使用方括号列索引后，再使用点的列索引
    except Warning as w:
        Warning_Msg = w
print(Warning_Msg)
df_chain
```

    
    A value is trying to be set on a copy of a slice from a DataFrame.Try using .loc[row_indexer,col_indexer] = value instead
    
    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_chain.loc[df_chain.A!=0,'B'] = 1
df_chain
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



#### [END]

### 4. ilocインデックス

 `iloc` の使用は `loc` と完全に似ていますが、位置ごとにフィルタリングされます。対応する `*` 位置には合計5種類の正当なオブジェクトがあります。それぞれ：整数、整数リスト、整数スライス、ブールリスト、関数。関数の戻り値は前の4種類の正当なオブジェクトのうちの1つでなければなりません、入力も `DataFrame` 自体です。




```python
df_demo.iloc[1, 1] # 第二行第二列
```




    'Freshman'





```python
df_demo.iloc[[0, 1], [0, 1]] # 前两行前两列
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_demo.iloc[1: 4, 2:4] # 切片不包含结束端点
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Gender</th>
      <th>Weight</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Changqiang You</th>
      <td>Male</td>
      <td>70.0</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Male</td>
      <td>89.0</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>Female</td>
      <td>41.0</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_demo.iloc[lambda x: slice(1, 4)] # 传入切片为返回值的函数
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



ブールリストを使用するときは、特に注意してください。 `Series` を入力しないでください。シーケンスの `values` を入力しなければなりません。そうしないとエラーが報告されます。したがって、ブールフィルタリングを使用するときは、やはり `loc` 方式を優先する必要があります。

たとえば、体重が80kg以上の学生を選択します。



```python
df_demo.iloc[(df_demo.Weight>80).values].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Zheng</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Han</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Zhou</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Feng Han</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>82.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



 `Series` の場合も、 `iloc` で対応する位置の値またはサブシーケンスを返すことができます：



```python
df_demo.School.iloc[1]
```




    'Peking University'





```python
df_demo.School.iloc[1:5:2]
```




    NameChangqiang You    Peking UniversityXiaojuan Sun       Fudan UniversityName: School, dtype: object



### 5. queryメソッド

 `pandas` では、文字列形式のクエリ式を `query` メソッドに渡してデータをクエリすることがサポートされています。その式の実行結果はブールリストを返す必要があります。複雑なインデックスを行う場合、通常の方法と同様に `DataFrame` の名前を繰り返し使用して列名を参照する必要がないため、読み取り性を低下させることなく、一般的にコードの長さを短縮することができる。

たとえば、 `loc` セクションの複合条件クエリの例を次のように書き換えることができます：



```python
df.query('((School == "Fudan University")&'
         ' (Grade == "Senior")&'
         ' (Weight > 70))|'
         '((School == "Peking University")&'
         ' (Grade != "Senior")&'
         ' (Weight > 80))')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>38</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Qiang Han</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>66</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>99</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Changpeng Zhao</td>
      <td>Male</td>
      <td>83.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>131</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chengpeng Qian</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



 `query` 式では、ユーザーが `DataFrame` からのすべての列名を登錄し、その `Series` に属するすべてのメソッドを呼び出すことができます。例えば、平均以上の体重を持つ学生のクエリなど、通常の関数呼び出しと変わらないです：



```python
df.query('Weight > Weight.mean()').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Gaojuan You</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Xiaopeng Zhou</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>14</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Xiaomei Zhou</td>
      <td>Female</td>
      <td>57.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



#### [NOTE] queryでスペースのあるカラム名を参照する

スペースが含まれているカラム名は、 `` `col name` `` で参照する必要があります。

#### [END]

また、いくつかの英語の文字通りの用法が `query` に登録されており、読みやすくなるのを助けています。たとえば、 `or, and, or, in, not in`。例えば、男子生徒の中で1、2年生ではない学生を選別します：



```python
df.query('(Grade not in ["Freshman", "Sophomore"]) and (Gender == "Male")').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>16</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Xiaoqiang Qin</td>
      <td>Male</td>
      <td>68.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>17</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Peng Wang</td>
      <td>Male</td>
      <td>65.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>18</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Xiaofeng Sun</td>
      <td>Male</td>
      <td>71.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>21</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Xiaopeng Shen</td>
      <td>Male</td>
      <td>62.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



さらに、 `==` および `!=` は、文字列内でリストとの比較が表示された場合、要素がリストに表示され、リストに表示されなかったことを示します。これは、 `in` および `not in` に相当します。たとえば、3年生と4年生のすべての学生をクエリします：



```python
df.query('Grade == ["Junior", "Senior"]').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Gaoqiang Qian</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>9</th>
      <td>Peking University</td>
      <td>Junior</td>
      <td>Juan Xu</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
    <tr>
      <th>11</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Xiaoquan Lv</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>12</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Peng You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



 `query` の文字列の場合、外部変数を参照する場合は、変数名の前に `@` 記号を付けるだけです。例えば、体重が70kgから80kgの間の学生を取り出します。



```python
low, high =70, 80
df.query('(Weight >= @low) & (Weight <= @high)').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Gaojuan You</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Xiaopeng Zhou</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>18</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Xiaofeng Sun</td>
      <td>Male</td>
      <td>71.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>35</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Gaoli Zhao</td>
      <td>Male</td>
      <td>78.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



### 6. ランダムサンプリング

 `DataFrame` の各行を1つのサンプルとして、または各列を1つの特徴として、そして `DataFrame` 全体を全体として、サンプルまたは特徴をランダムにサンプリングするには、 `sample` 関数を使用することができます。大規模なデータセットを手に入れた後、統計的特徴を計算してデータの大まかな分布を理解したい場合がありますが、これは時間がかかります。同時に、多くの統計的特徴は、等確率で戻されない簡単なランダムサンプリング条件の下で、サンプル平均値や全体平均値など、全体統計的特徴の偏りのない推定であるため、まず表全体から一部を抽出して近似推定をすることができる。

 `sample` 関数の主な引数は `n, axis, frac, replace, weights` で、最初の3つはそれぞれサンプル数、サンプル方向（0は行、1は列）、サンプル割合（0.3は全体から30%のサンプルを抽出する）を指します。

 `replace` および `weights` はそれぞれサンプルごとのサンプリングの相対確率を指し、 `replace = True` の場合はサンプリングのサンプリングがあることを示します。たとえば、以下のように構成された `df_sample` に対して、 `value` 値の相対的な大きさをサンプリング確率とし、サンプリング数は3である。



```python
df_sample = pd.DataFrame({'id': list('abcde'), 'value': [1, 2, 3, 4, 90]})
df_sample
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>c</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>d</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>e</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_sample.sample(3, replace = True, weights = df_sample.value)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>e</td>
      <td>90</td>
    </tr>
    <tr>
      <th>4</th>
      <td>e</td>
      <td>90</td>
    </tr>
    <tr>
      <th>4</th>
      <td>e</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>



## 2. マルチレベル索引
### 1. マルチレベルインデックスとそのテーブルの構造

マルチレベルのインデックスを持つ `DataFrame` 構造をより明確に説明するために、次の新しいテーブルを構築します。読者はここでの構造方法を無視してもいいです。これらは4節でより詳しく説明されます。



```python
np.random.seed(0)
multi_index = pd.MultiIndex.from_product([list('ABCD'), df.Gender.unique()], names=('School', 'Gender'))
multi_column = pd.MultiIndex.from_product([['Height', 'Weight'], df.Grade.unique()], names=('Indicator', 'Grade'))
df_multi = pd.DataFrame(np.c_[(np.random.randn(8,4)*5 + 163).tolist(), (np.random.randn(8,4)*5 + 65).tolist()],
                        index = multi_index, columns = multi_column).round(1)
df_multi
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Indicator</th>
      <th colspan="4" halign="left">Height</th>
      <th colspan="4" halign="left">Weight</th>
    </tr>
    <tr>
      <th></th>
      <th>Grade</th>
      <th>Freshman</th>
      <th>Senior</th>
      <th>Sophomore</th>
      <th>Junior</th>
      <th>Freshman</th>
      <th>Senior</th>
      <th>Sophomore</th>
      <th>Junior</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Gender</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>Female</th>
      <td>171.8</td>
      <td>165.0</td>
      <td>167.9</td>
      <td>174.2</td>
      <td>60.6</td>
      <td>55.1</td>
      <td>63.3</td>
      <td>65.8</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>172.3</td>
      <td>158.1</td>
      <td>167.8</td>
      <td>162.2</td>
      <td>71.2</td>
      <td>71.0</td>
      <td>63.1</td>
      <td>63.5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">B</th>
      <th>Female</th>
      <td>162.5</td>
      <td>165.1</td>
      <td>163.7</td>
      <td>170.3</td>
      <td>59.8</td>
      <td>57.9</td>
      <td>56.5</td>
      <td>74.8</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>166.8</td>
      <td>163.6</td>
      <td>165.2</td>
      <td>164.7</td>
      <td>62.5</td>
      <td>62.8</td>
      <td>58.7</td>
      <td>68.9</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">C</th>
      <th>Female</th>
      <td>170.5</td>
      <td>162.0</td>
      <td>164.6</td>
      <td>158.7</td>
      <td>56.9</td>
      <td>63.9</td>
      <td>60.5</td>
      <td>66.9</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>150.2</td>
      <td>166.3</td>
      <td>167.3</td>
      <td>159.3</td>
      <td>62.4</td>
      <td>59.1</td>
      <td>64.9</td>
      <td>67.1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">D</th>
      <th>Female</th>
      <td>174.3</td>
      <td>155.7</td>
      <td>163.2</td>
      <td>162.1</td>
      <td>65.3</td>
      <td>66.5</td>
      <td>61.8</td>
      <td>63.2</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>170.7</td>
      <td>170.3</td>
      <td>163.8</td>
      <td>164.9</td>
      <td>61.6</td>
      <td>63.2</td>
      <td>60.9</td>
      <td>56.4</td>
    </tr>
  </tbody>
</table>
</div>



以下の図は、 `DataFrame` の構造を色で区別してマークしています。単一レベルインデックスのテーブルと同様に、要素値、行インデックス、列インデックスの3つの部分を備えています。ここで、行インデックスと列インデックスはいずれも `MultiIndex` 型ですが、単一レベルのインデックス内のスカラーではなく**インデックス内の要素の1つはタプルです**です。たとえば、行インデックスの4番目の要素は `("B", "Male")`、列インデックスの2番目の要素は `("Height", "Senior")` です。ここで注意してください。外側に同じ値が連続して表示される場合、1回目の後に表示されるものは非表示になり、結果の読み取り性が向上します。

<img src="../source/_static/multi_index.png" width="50%">

シングルレベルのインデックスと同様に、 `MultiIndex` には名前属性があり、図の `School` と `Gender` はそれぞれ表の第1レベルと第2レベルの行インデックスの名前に対応し、 `Indicator` と `Grade` はそれぞれ第1レベルと第2レベルの列インデックスの名前に対応します。

インデックスの名前属性と値属性は、それぞれ `names` と `values` で取得できます：



```python
df_multi.index.names
```




    FrozenList(['School', 'Gender'])





```python
df_multi.columns.names
```




    FrozenList(['Indicator', 'Grade'])





```python
df_multi.index.values
```




    array([('A', 'Female'), ('A', 'Male'), ('B', 'Female'), ('B', 'Male'),
           ('C', 'Female'), ('C', 'Male'), ('D', 'Female'), ('D', 'Male')],
          dtype=object)





```python
df_multi.columns.values
```




    array([('Height', 'Freshman'), ('Height', 'Senior'),
           ('Height', 'Sophomore'), ('Height', 'Junior'),('Weight', 'Freshman'), ('Weight', 'Senior'),('Weight', 'Sophomore'), ('Weight', 'Junior')], dtype=object)



特定のレベルのインデックスを取得したい場合は、 `get_level_values` で取得する必要があります：



```python
df_multi.index.get_level_values(0)
```




    Index(['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D'], dtype='object', name='School')



しかし、インデックスの場合、単一レベルであれ、複数レベルであれ、ユーザーは要素を `index_obj[0] = item` で変更することはできません。また、名前を `index_name[0] = new_name` で変更することはできません。これらの属性を変更する方法については第3節で議論します。

### 2. マルチレベルインデックスにおけるlocインデックス化

構造を熟知した後、元のテーブルに戻り、学校と学年をインデックスに設定します。このときの動作はマルチレベルインデックスで、単一レベルインデックスにリストされます。デフォルトのカラムインデックスには名前が含まれていないため、さっきの図の `Indicator` と `Grade` に対応するインデックス名の位置は空いています。



```python
df_multi = df.set_index(['School', 'Grade'])
df_multi.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Freshman</th>
      <td>Gaopeng Yang</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <th>Freshman</th>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Senior</th>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Fudan University</th>
      <th>Sophomore</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Gaojuan You</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



マルチレベルインデックスの個々の要素はタプル単位であるため、前の第1節で紹介した``loc``と``iloc``メソッドは完全にコピーできます。スカラーの位置を対応するタプルに置き換えるだけです。

タプルリストまたは単一のタプル、または最初の2つを返す関数を渡すときは、パフォーマンス警告を回避するために、インデックスソートを行う必要があります：



```python
with warnings.catch_warnings():
    warnings.filterwarnings('error')
    try:
        df_multi.loc[('Fudan University', 'Junior')].head()
    except Warning as w:
        Warning_Msg = w
Warning_Msg
```




    pandas.errors.PerformanceWarning('indexing past lexsort depth may impact performance.')





```python
df_sorted = df_multi.sort_index()
df_sorted.loc[('Fudan University', 'Junior')].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Junior</th>
      <td>Yanli You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Chunqiang Chu</td>
      <td>Male</td>
      <td>72.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changfeng Lv</td>
      <td>Male</td>
      <td>76.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Yanjuan Lv</td>
      <td>Female</td>
      <td>49.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoqiang Zhou</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_sorted.loc[[('Fudan University', 'Senior'), ('Shanghai Jiao Tong University', 'Freshman')]].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Senior</th>
      <td>Chengpeng Zheng</td>
      <td>Female</td>
      <td>38.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Feng Zhou</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Gaomei Lv</td>
      <td>Female</td>
      <td>34.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chunli Lv</td>
      <td>Female</td>
      <td>56.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_sorted.loc[df_sorted.Weight > 70].head() # 布尔列表也是可用的
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Freshman</th>
      <td>Feng Wang</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Chunqiang Chu</td>
      <td>Male</td>
      <td>72.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changfeng Lv</td>
      <td>Male</td>
      <td>76.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Qian</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_sorted.loc[lambda x:('Fudan University','Junior')].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Junior</th>
      <td>Yanli You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Chunqiang Chu</td>
      <td>Male</td>
      <td>72.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changfeng Lv</td>
      <td>Male</td>
      <td>76.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Yanjuan Lv</td>
      <td>Female</td>
      <td>49.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoqiang Zhou</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



スライスを使用するときは、シングルレベルのインデックスでは、スライスのエンドポイント要素が一意であればスライスを行うことができますが、マルチレベルのインデックスでは、タプルがインデックスに繰り返されるかどうかにかかわらず、スライスを使用する前にソートしなければなりません。そうしないとエラーが報告されます：



```python
try:
    df_multi.loc[('Fudan University', 'Senior'):].head()
except Exception as e:
    Err_Msg = e
Err_Msg
```




    pandas.errors.UnsortedIndexError('Key length (2) was greater than MultiIndex lexsort depth (0)')





```python
df_sorted.loc[('Fudan University', 'Senior'):].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Senior</th>
      <td>Chengpeng Zheng</td>
      <td>Female</td>
      <td>38.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Feng Zhou</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Gaomei Lv</td>
      <td>Female</td>
      <td>34.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chunli Lv</td>
      <td>Female</td>
      <td>56.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_unique = df.drop_duplicates(subset=['School','Grade']).set_index(['School', 'Grade'])
df_unique.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Freshman</th>
      <td>Gaopeng Yang</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <th>Freshman</th>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Senior</th>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Fudan University</th>
      <th>Sophomore</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Tsinghua University</th>
      <th>Freshman</th>
      <td>Xiaoli Qian</td>
      <td>Female</td>
      <td>51.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>





```python
try:
    df_unique.loc[('Fudan University', 'Senior'):].head()
except Exception as e:
    Err_Msg = e
Err_Msg
```




    pandas.errors.UnsortedIndexError('Key length (2) was greater than MultiIndex lexsort depth (0)')





```python
df_unique.sort_index().loc[('Fudan University', 'Senior'):].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Fudan University</th>
      <th>Senior</th>
      <td>Chengpeng Zheng</td>
      <td>Female</td>
      <td>38.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">Peking University</th>
      <th>Freshman</th>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Juan Xu</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Changli Lv</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



さらに、複数レベルのインデックスでのタプルは、複数レベルの要素を交差組み合わせてインデックス化する特別な用途がありますが、同時に `loc` の列を指定する必要があり、すべてを選択する場合は `:` で表されます。ここで、各レイヤーで選択する必要がある要素はリストとして保存され、 `loc` の形式は `[(level_0_list, level_1_list), cols]` に渡されます。例えば、北京大学と復旦大学の大学2、大学3年生をすべて獲得したい場合は、次のように書くことができます：



```python
res = df_multi.loc[(['Peking University', 'Fudan University'], ['Sophomore', 'Junior']), :]
res.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Peking University</th>
      <th>Sophomore</th>
      <td>Changmei Xu</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Xiaopeng Qin</td>
      <td>Male</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Mei Xu</td>
      <td>Female</td>
      <td>39.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Xiaoli Zhou</td>
      <td>Female</td>
      <td>55.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Peng Han</td>
      <td>Female</td>
      <td>34.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>





```python
res.shape
```




    (33, 4)



次の文は上記と似ていますが、依然として伝わってくるのは要素（ここではタプル）のリストであり、それらの意味は異なり、北京大学の大学3年生と復旦大学の大学2年生を選ぶことを示しています：



```python
res = df_multi.loc[[('Peking University', 'Junior'), ('Fudan University', 'Sophomore')]]
res.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Peking University</th>
      <th>Junior</th>
      <td>Juan Xu</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changjuan You</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoli Xu</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoquan Zhou</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Qiang You</td>
      <td>Female</td>
      <td>56.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>





```python
res.shape
```




    (16, 4)



### 3. IndexSliceオブジェクト

先に紹介した方法では、インデックスが重複していない場合でも、タプル全体をスライスするだけで、レイヤーごとにスライスすることはできず、スライスとブールリストを混在させることもできません。 `IndexSlice` オブジェクトを導入することでこの問題を解決できます。 `Slice` オブジェクトには2つの形式があります。1つ目は `loc[idx[*,*]]` タイプ、2つ目は `loc[idx[*,*],idx[*,*]]` タイプです。デモンストレーションを容易にするために、**インデックスが重複しない** `DataFrame` を構築します：



```python
np.random.seed(0)
L1,L2 = ['A','B','C'],['a','b','c']
mul_index1 = pd.MultiIndex.from_product([L1,L2],names=('Upper', 'Lower'))
L3,L4 = ['D','E','F'],['d','e','f']
mul_index2 = pd.MultiIndex.from_product([L3,L4],names=('Big', 'Small'))
df_ex = pd.DataFrame(np.random.randint(-9,10,(9,9)), index=mul_index1, columns=mul_index2)
df_ex
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th colspan="3" halign="left">D</th>
      <th colspan="3" halign="left">E</th>
      <th colspan="3" halign="left">F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">A</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
      <td>-4</td>
      <td>4</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">B</th>
      <th>a</th>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
    </tr>
    <tr>
      <th>c</th>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">C</th>
      <th>a</th>
      <td>-6</td>
      <td>-3</td>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1</td>
      <td>2</td>
      <td>-5</td>
      <td>-3</td>
      <td>-5</td>
      <td>6</td>
      <td>-6</td>
      <td>3</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-1</td>
      <td>5</td>
      <td>6</td>
      <td>-6</td>
      <td>6</td>
      <td>4</td>
      <td>7</td>
      <td>8</td>
      <td>-4</td>
    </tr>
  </tbody>
</table>
</div>



 `silce` オブジェクトを使用するには、まず次の定義を行います。



```python
idx = pd.IndexSlice
```

[a] `loc[idx[*,*]]` 型

この場合、複数のレイヤーを別々にスライスすることはできません。前の `*` は行の選択を表し、後の `*` は列の選択を表します。単純な `loc` と同様です。



```python
df_ex.loc[idx['C':, ('D', 'f'):]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th>D</th>
      <th colspan="3" halign="left">E</th>
      <th colspan="3" halign="left">F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">C</th>
      <th>a</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-5</td>
      <td>-3</td>
      <td>-5</td>
      <td>6</td>
      <td>-6</td>
      <td>3</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>c</th>
      <td>6</td>
      <td>-6</td>
      <td>6</td>
      <td>4</td>
      <td>7</td>
      <td>8</td>
      <td>-4</td>
    </tr>
  </tbody>
</table>
</div>



ブールシーケンスのインデックスもサポートされています：



```python
df_ex.loc[idx[:'A', lambda x:x.sum()>0]] # 列和大于0
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th colspan="2" halign="left">D</th>
      <th>F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>d</th>
      <th>e</th>
      <th>e</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">A</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-3</td>
      <td>3</td>
      <td>-4</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-1</td>
      <td>0</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



[b] `loc[idx[*,*],idx[*,*]]` 型

この場合、階層的にスライスすることができます。前の `idx` はローインデックスを指し、後の列インデックスを指します。



```python
df_ex.loc[idx[:'A', 'b':], idx['E':, 'e':]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th colspan="2" halign="left">E</th>
      <th colspan="2" halign="left">F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>e</th>
      <th>f</th>
      <th>e</th>
      <th>f</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>b</th>
      <td>-2</td>
      <td>5</td>
      <td>-4</td>
      <td>4</td>
    </tr>
    <tr>
      <th>c</th>
      <td>6</td>
      <td>6</td>
      <td>9</td>
      <td>-6</td>
    </tr>
  </tbody>
</table>
</div>



ただし、関数の使用はこの時点でサポートされていないことに注意してください：



```python
try:
    df_ex.loc[idx[:'A', lambda x: 'b'], idx['E':, 'e':]]
except Exception as e:
    Err_Msg = e
Err_Msg
```




    KeyError(<function __main__.<lambda>(x)>)



### 4. マルチレベルインデックスの構築

マルチレベルインデックステーブルの構造とスライスについては前述しましたが、 `set_index` を使う以外に、マルチレベルインデックスを自分で構築するにはどうすればいいでしょうか？一般的に使用されるメソッドは `from_tuples, from_arrays, from_product` の3つで、それらはすべて `pd.MultiIndex` オブジェクトの下の関数です。

 `from_tuples` タプルからなるリストを受け取ることから構築することを意味します：



```python
my_tuple = [('a','cat'),('a','dog'),('b','cat'),('b','dog')]
pd.MultiIndex.from_tuples(my_tuple, names=['First','Second'])
```




    MultiIndex([('a', 'cat'),
                ('a', 'dog'),('b', 'cat'),('b', 'dog')],
               names=['First', 'Second'])



 `from_arrays` 受信したリスト内の対応するレイヤーのリストに基づいて構築することを意味します：



```python
my_array = [list('aabb'), ['cat', 'dog']*2]
pd.MultiIndex.from_arrays(my_array, names=['First','Second'])
```




    MultiIndex([('a', 'cat'),
                ('a', 'dog'),('b', 'cat'),('b', 'dog')],
               names=['First', 'Second'])



 `from_product` は、複数のリストを与えたデカルト積から構築することを意味します。



```python
my_list1 = ['a','b']
my_list2 = ['cat','dog']
pd.MultiIndex.from_product([my_list1, my_list2], names=['First','Second'])
```




    MultiIndex([('a', 'cat'),
                ('a', 'dog'),('b', 'cat'),('b', 'dog')],
               names=['First', 'Second'])



## 三、索引の一般的な方法
### 1. インデックスレイヤの交換と削除
交換のプロセスを理解しやすくするために、ここでは3段階のインデックスの例を構築します：



```python
np.random.seed(0)
L1,L2,L3 = ['A','B'],['a','b'],['alpha','beta']
mul_index1 = pd.MultiIndex.from_product([L1,L2,L3], names=('Upper', 'Lower','Extra'))
L4,L5,L6 = ['C','D'],['c','d'],['cat','dog']
mul_index2 = pd.MultiIndex.from_product([L4,L5,L6], names=('Big', 'Small', 'Other'))
df_ex = pd.DataFrame(np.random.randint(-9,10,(8,8)), index=mul_index1,  columns=mul_index2)
df_ex
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">B</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
      <td>-6</td>
      <td>-3</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



インデックスレイヤーのスワップは、2つのレイヤーのみをスワップできる `swaplevel` と、任意のレイヤーをスワップできる `reorder_levels` によって行われます。どちらも、行インデックスまたは列インデックスのどちらをスワップするかを指定できます：



```python
df_ex.swaplevel(0,2,axis=1).head() # 列索引的第一层和第三层交换
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th>c</th>
      <th>c</th>
      <th>d</th>
      <th>d</th>
      <th>c</th>
      <th>c</th>
      <th>d</th>
      <th>d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th>C</th>
      <th>C</th>
      <th>C</th>
      <th>C</th>
      <th>D</th>
      <th>D</th>
      <th>D</th>
      <th>D</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_ex.reorder_levels([2,0,1],axis=0).head() # 列表数字指代原来索引中的层
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Extra</th>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>alpha</th>
      <th>A</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <th>A</th>
      <th>a</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>alpha</th>
      <th>A</th>
      <th>b</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <th>A</th>
      <th>b</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>alpha</th>
      <th>B</th>
      <th>a</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



#### [NOTE] 軸間のインデックス交換
ここでは行または列のインデックス内の交換のみが扱われ、異なる方向のインデックス間の交換は第5章で議論されます。
#### [END]
レベルのインデックスを削除するには、 `droplevel` メソッドを使用します：



```python
df_ex.droplevel(1,axis=1)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">B</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
      <td>-6</td>
      <td>-3</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_ex.droplevel([0,1],axis=0)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>alpha</th>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
      <td>-6</td>
      <td>-3</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



### 2. インデックス属性の変更
インデックスレイヤーの名前は `rename_axis` で変更できます。一般的な変更方法は、辞書のマッピングに渡されます：



```python
df_ex.rename_axis(index={'Upper':'Changed_row'}, columns={'Other':'Changed_Col'}).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Changed_Col</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Changed_row</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



インデックスの値は `rename` で変更できます。マルチレベルインデックスの場合は、変更するレイヤー番号 `level` を指定する必要があります：



```python
df_ex.rename(columns={'cat':'not_cat'}, level=2).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>not_cat</th>
      <th>dog</th>
      <th>not_cat</th>
      <th>dog</th>
      <th>not_cat</th>
      <th>dog</th>
      <th>not_cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



受信パラメータは関数でもあり、その入力値はインデックス要素です：



```python
df_ex.rename(index=lambda x:str.upper(x), level=2).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>ALPHA</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>BETA</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>ALPHA</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>BETA</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>ALPHA</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



#### [練習して練習する]
 `rename_axis` の関数を使用して、 `Upper` と `Other` をそれぞれ `Changed_row` と `Changed_col` に置き換えてみてください。
#### [END]
インデックス全体の要素置換のために、イテレータを使用して実装できます：



```python
new_values = iter(list('abcdefgh'))
df_ex.rename(index=lambda x:next(new_values), level=2)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>c</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>d</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">B</th>
      <th rowspan="2" valign="top">a</th>
      <th>e</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>f</th>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>g</th>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
      <td>-6</td>
      <td>-3</td>
    </tr>
    <tr>
      <th>h</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



ある位置の要素を修正したい場合は、インデックスの `values` 属性をまず取り出し、得られたリストを修正し、最後に `index` オブジェクトに値を再割り当てる単一レベルのインデックスで容易に実現することができます。ただし、マルチレベルインデックスの場合はやや面倒であり、一つの解決策は、まずあるレベルのインデックスを一時的にテーブルの要素に変更し、それを修正し、最後にインデックスに再設定することであり、次の節ではこれらの操作を紹介する。

もう1つの関数は `map` です。これは `Index` 上に定義されたメソッドです。前の `rename` メソッドのレイヤの関数的な使用と同様です。レイヤのスカラー値ではなく、インデックスのタプルを直接渡します。これはユーザーがレイヤを跨ぐ修正を行うためのトラバースを提供します。たとえば、上記の文字列を大文字化する操作を同等に書くことができます：



```python
df_temp = df_ex.copy()
new_idx = df_temp.index.map(lambda x: (x[0], x[1], str.upper(x[2])))
df_temp.index = new_idx
df_temp.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>ALPHA</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>BETA</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>ALPHA</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>BETA</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>ALPHA</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



 `map` のもう1つの使用方法は、マルチレベルインデックスの圧縮です。これは、第4章と第5章のいくつかの操作で有用です。



```python
df_temp = df_ex.copy()
new_idx = df_temp.index.map(lambda x: (x[0]+'-'+x[1]+'-'+x[2]))
df_temp.index = new_idx
df_temp.head() # 单层索引
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A-a-alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>A-a-beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>A-b-alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>A-b-beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B-a-alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



また、逆方向に展開することもできます：



```python
new_idx = df_temp.index.map(lambda x:tuple(x.split('-')))
df_temp.index = new_idx
df_temp.head() # 三层索引
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



### 3. インデックスの設定とリセット
このセクションの関数を説明するために、次のように新しいテーブルを構築します：



```python
df_new = pd.DataFrame({'A':list('aacd'), 'B':list('PQRT'), 'C':[1,2,3,4]})
df_new
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>a</td>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>c</td>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>d</td>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



インデックスの設定は `set_index` を使用して行うことができます。ここでの主な引数は `append` で、元のインデックスを保持し、新しい設定を元のインデックスの内部レイヤーに直接追加するかどうかを示します。



```python
df_new.set_index('A')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>a</th>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_new.set_index('A', append=True)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th></th>
      <th>A</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <th>a</th>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <th>a</th>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <th>c</th>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <th>d</th>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



インデックスとして複数の列を同時に指定できます：



```python
df_new.set_index(['A', 'B'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th>B</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>P</th>
      <td>1</td>
    </tr>
    <tr>
      <th>Q</th>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <th>R</th>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <th>T</th>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



インデックスを追加したいカラムが表示されない場合は、引数に対応する `Series` を直接入力できます。



```python
my_index = pd.Series(list('WXYZ'), name='D')
df_new = df_new.set_index(['A', my_index])
df_new
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th>D</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>W</th>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>X</th>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <th>Y</th>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <th>Z</th>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



 `reset_index` は `set_index` の逆関数で、主な引数は `drop` で、削除されたインデックスレイヤーを列に追加するのではなく廃棄するかどうかを示します。



```python
df_new.reset_index(['D'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>D</th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>W</td>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>a</th>
      <td>X</td>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <td>Y</td>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <td>Z</td>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_new.reset_index(['D'], drop=True)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>a</th>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



すべてのインデックスがリセットされた場合、 `pandas` はデフォルトのインデックスを直接再生成します。



```python
df_new.reset_index()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>D</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>W</td>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>a</td>
      <td>X</td>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>c</td>
      <td>Y</td>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>d</td>
      <td>Z</td>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



### 4. インデックスの変形
場合によっては、インデックスをいくつか拡張または除去する必要があり、より具体的には新しいインデックスを与え、元のテーブルの対応するインデックスに対応する要素を新しいインデックスで構成されたテーブルに充填することが要求される。たとえば、次の表に従業員情報が示されています。新しい表を作り直して、従業員を1人追加し、身長列を削除し、性別列を追加する必要があります：



```python
df_reindex = pd.DataFrame({"Weight":[60,70,80], "Height":[176,180,179]}, index=['1001','1003','1002'])
df_reindex
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Weight</th>
      <th>Height</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1001</th>
      <td>60</td>
      <td>176</td>
    </tr>
    <tr>
      <th>1003</th>
      <td>70</td>
      <td>180</td>
    </tr>
    <tr>
      <th>1002</th>
      <td>80</td>
      <td>179</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_reindex.reindex(index=['1001','1002','1003','1004'], columns=['Weight','Gender'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Weight</th>
      <th>Gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1001</th>
      <td>60.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1002</th>
      <td>80.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1003</th>
      <td>70.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1004</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



このような要件は、時系列インデックスのタイムポイントのパディングや `ID` 番号の拡張によく現れます。また、元のテーブルのデータと新しいテーブルのデータはインデックスに基づいて自動的に整列されることに注意してください。例えば、元の1002番目の位置が1003番目の後にあり、新しいテーブルの場合は逆の場合、 `reindex` では位置に関係なく要素に基づいて整列されます。

 `reindex` と同様の机能を持つもう一つの関数は `reindex_like` で、呼び出されたテーブルのインデックスを受信したテーブルのインデックスに基づいて変形する机能です。たとえば、ターゲットインデックスの条件を備えたテーブルがすでに存在する場合、上記の機能は次のコードを使用して実現できます：



```python
df_existed = pd.DataFrame(index=['1001','1002','1003','1004'], columns=['Weight','Gender'])
df_reindex.reindex_like(df_existed)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Weight</th>
      <th>Gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1001</th>
      <td>60.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1002</th>
      <td>80.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1003</th>
      <td>70.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1004</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



## 四、索引演算
### 1. 集合のアルゴリズム

集合演算を使用して条件を満たす行を取り出す必要がよくあります。たとえば、インデックスは従業員番号である2つのテーブル `A` と `B` があります。現在、2つのテーブルのインデックスが交差するすべての従業員情報をフィルタリングする必要があります。この場合、 `Index` 上の演算操作で簡単に実現できます。

しかし、その前に、一般的な4つの集合演算を復習してみてはいかがでしょうか：

$$\rm S_A.intersection(S_B) = \rm S_A \cap S_B \Leftrightarrow \rm \{x|x\in S_A\, and\, x\in S_B\}$$
$$\rm S_A.union (S_B) =\rm S_A\cup S_B\Leftrightarrow\rm\ {xx\in S_A\,or\,x\in S_B\} $$ $$\rm S_A.difference(S_B) = \rm S_A - S_B \Leftrightarrow \rm \{x|x\in S_A\, and\, x\notin S_B\}$$
$$\rm S_A.symmetric\_difference (S_B) =\rm S_A\triangle S_B\Leftrightarrow\rm\ {xx\in S_A\cup S_B-S_A\cap S_B\} $$

### 2. 一般的なインデックス演算

コレクションの要素は互いに異なるが、インデックスに同じ要素がある可能性があるため、まず `unique` で重複を除去してから演算します。次の2つの最も簡単なサンプルテーブルを構築して示します：



```python
df_set_1 = pd.DataFrame([[0,1],[1,2],[3,4]], index = pd.Index(['a','b','a'],name='id1'))
df_set_2 = pd.DataFrame([[4,5],[2,6],[7,1]], index = pd.Index(['b','b','c'],name='id2'))
id1, id2 = df_set_1.index.unique(), df_set_2.index.unique()
id1.intersection(id2)
```




    Index(['b'], dtype='object')





```python
id1.union(id2)
```




    Index(['a', 'b', 'c'], dtype='object')





```python
id1.difference(id2)
```




    Index(['a'], dtype='object')





```python
id1.symmetric_difference(id2)
```




    Index(['a', 'c'], dtype='object')



2つのテーブルで集合演算を行う必要がある列がインデックスが設定されていない場合、1つの方法はまずインデックスに変換して演算した後に復元することです。もう1つの方法は、インデックスをリセットした最初のテーブルでid列の交差がある行を選択するように `isin` 関数を使用することです。



```python
df_set_in_col_1 = df_set_1.reset_index()
df_set_in_col_2 = df_set_2.reset_index()
df_set_in_col_1
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id1</th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>a</td>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_set_in_col_2
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id2</th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>2</td>
      <td>6</td>
    </tr>
    <tr>
      <th>2</th>
      <td>c</td>
      <td>7</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_set_in_col_1[df_set_in_col_1.id1.isin(df_set_in_col_2.id2)]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id1</th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



## 五、練習
### Ex1：会社の従業員データセット
既存の社員データセット：



```python
df = pd.read_csv('../data/company.csv')
df.head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
      <th>department</th>
      <th>job_title</th>
      <th>gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1318</td>
      <td>1/3/1954</td>
      <td>61</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>CEO</td>
      <td>M</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1319</td>
      <td>1/3/1957</td>
      <td>58</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>VP Stores</td>
      <td>F</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1320</td>
      <td>1/2/1955</td>
      <td>60</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>Legal Counsel</td>
      <td>F</td>
    </tr>
  </tbody>
</table>
</div>



1. それぞれ `query` と `loc` を使用して、40歳未満の男性のみを選択し、 `Dairy` または `Bakery` に勤務している男性を選択します。
2. 従業員 `ID` 番号が奇数の行の1列目、3列目、最後から2列目を選択します。
3. インデックスを実行するには、次の手順に従います：

* 最後の3列をインデックスにした後、内外の2つのレイヤーを交換する
* 中間層インデックスのリカバリ
* 外側インデックス名を `Gender` に変更する
* 2つのレベルの行インデックスを下線で結合する
* 行インデックスを元の状態に分割する
* 索引名を元のテーブル名に変更する
* デフォルトのインデックスを復元し、カラムを元のテーブルの相対的な位置に維持する

### Ex2：チョコレートデータセット
チョコレート評価に関するデータセットがあります：



```python
df = pd.read_csv('../data/chocolate.csv')
df.head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Company</th>
      <th>Review\r\nDate</th>
      <th>Cocoa\r\nPercent</th>
      <th>Company\r\nLocation</th>
      <th>Rating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A. Morin</td>
      <td>2016</td>
      <td>63%</td>
      <td>France</td>
      <td>3.75</td>
    </tr>
    <tr>
      <th>1</th>
      <td>A. Morin</td>
      <td>2015</td>
      <td>70%</td>
      <td>France</td>
      <td>2.75</td>
    </tr>
    <tr>
      <th>2</th>
      <td>A. Morin</td>
      <td>2015</td>
      <td>70%</td>
      <td>France</td>
      <td>3.00</td>
    </tr>
  </tbody>
</table>
</div>



1. 列のインデックス名の `\n` をスペースに置き換えます。
2. チョコレート `Rating` は0.25点ごとに1~5のスコアで、2.75点以下でココア含有量 `Cocoa Percent` が中央値より高いサンプルを選んでください。
3.  `Review Date` と `Company Location` をインデックスにした后、 `Review Date` が2012年以降であり、 `Company Location` が `France, Canada, Amsterdam, Belgium` に属していないサンプルを選択します。
