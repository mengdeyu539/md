<center> <h1>第 5 章変形 </h1></center>



```python
import numpy as np
import pandas as pd
```

## 一、縦横表の変形

ロングウォッチとは何ですか？ワイドテーブルとは何ですか？この概念は特定の特徴に対するものです。例えば、あるテーブルに性別がある列に格納されている場合、それは性別に関する長いテーブルになります。性別を列名とし、列内の要素が別の関連特徴数値であれば、この表は性別に関する広い表となる。次の2つの表は、それぞれ性別に関する長表と幅表です：



```python
pd.DataFrame({'Gender':['F','F','M','M'], 'Height':[163, 160, 175, 180]})
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Gender</th>
      <th>Height</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>F</td>
      <td>163</td>
    </tr>
    <tr>
      <th>1</th>
      <td>F</td>
      <td>160</td>
    </tr>
    <tr>
      <th>2</th>
      <td>M</td>
      <td>175</td>
    </tr>
    <tr>
      <th>3</th>
      <td>M</td>
      <td>180</td>
    </tr>
  </tbody>
</table>
</div>





```python
pd.DataFrame({'Height: F':[163, 160], 'Height: M':[175, 180]})
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Height: F</th>
      <th>Height: M</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>163</td>
      <td>175</td>
    </tr>
    <tr>
      <th>1</th>
      <td>160</td>
      <td>180</td>
    </tr>
  </tbody>
</table>
</div>



明らかに、この2つの表は情報的に完全に等価であり、同じ身長統計値を含んでいるが、これらの値の提示方法が異なり、その提示方法は主に性別列で選択されたレイアウトパターンに関連している。つまり、$\color {red} {long} $の状態で格納されるか$\color {red} {wide} $の状態で格納されるか。したがって、 `pandas` このような縦横テーブルの変形操作に関連するいくつかの変形関数を設計しました。

### 1. pivot

 `pivot` は典型的な長いテーブルを広くする関数であり、まず例を見てみましょう：次の表には張三と李四の国語と数学の点数が格納されています。今は国語と数学の点数を列として表示したいと思います。



```python
df = pd.DataFrame({'Class':[1,1,2,2],
                   'Name':['San Zhang','San Zhang','Si Li','Si Li'],
                   'Subject':['Chinese','Math','Chinese','Math'],
                   'Grade':[80,75,90,85]})
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Class</th>
      <th>Name</th>
      <th>Subject</th>
      <th>Grade</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Chinese</td>
      <td>80</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Math</td>
      <td>75</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Chinese</td>
      <td>90</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Math</td>
      <td>85</td>
    </tr>
  </tbody>
</table>
</div>



基本的な長さ拡幅操作のために最も重要な要素は、変形された行インデックス、列インデックスに移行する必要がある列、およびこれらの列と行インデックスに対応する数値であり、それぞれ `pivot` メソッドの `index, columns, values` パラメータに対応しています。新しく生成されたテーブルの列インデックスは `columns` に対応する列の `unique` 値であり、新しいテーブルの行インデックスは `index` に対応する列の `unique` 値であり、 `values` は表示したい数値列に対応しています。



```python
df.pivot(index='Name', columns='Subject', values='Grade')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Subject</th>
      <th>Chinese</th>
      <th>Math</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>San Zhang</th>
      <td>80</td>
      <td>75</td>
    </tr>
    <tr>
      <th>Si Li</th>
      <td>90</td>
      <td>85</td>
    </tr>
  </tbody>
</table>
</div>



色のマーキングによって、変形のプロセスを理解することが容易になります：

<img src="../source/_static/ch5_pivot.png" width="20%">

 `pivot` を使用した変形操作は一意性の要件を満たす必要があります。つまり、新しいテーブルの列と列のインデックスは一意の `value` に対応しているため、元のテーブルの2つの列に対応する行の組み合わせ `index` と `columns` は一意でなければなりません。例えば、現在、元の表の2行目の張三の数学を国語に変更するとエラーが報告されます。これは、 `Name` と `Subject` の組み合わせに `("San Zhang", "Chinese")` が2回現れ、最終的に変形した後に80点を記入すべきか75点を記入すべきかを判断できません。



```python
df.loc[1, 'Subject'] = 'Chinese'
try:
    df.pivot(index='Name', columns='Subject', values='Grade')
except Exception as e:
    Err_Msg = e
Err_Msg
```




    ValueError('Index contains duplicate entries, cannot reshape')



 `pandas` `1.1.0` 以降、 `pivot` に関連する3つの引数をリストとして設定することができます。つまり、復数レベルのインデックスが返されることも意味します。ここでは、対応する例を構築して使用方法を説明します。次の表の6つの列は、クラス、名前、テストタイプ（中間試験と期末試験）、科目、成績、順位です。



```python
df = pd.DataFrame({'Class':[1, 1, 2, 2, 1, 1, 2, 2],
                   'Name':['San Zhang', 'San Zhang', 'Si Li', 'Si Li',
                              'San Zhang', 'San Zhang', 'Si Li', 'Si Li'],
                   'Examination': ['Mid', 'Final', 'Mid', 'Final',
                                    'Mid', 'Final', 'Mid', 'Final'],
                   'Subject':['Chinese', 'Chinese', 'Chinese', 'Chinese',
                                 'Math', 'Math', 'Math', 'Math'],
                   'Grade':[80, 75, 85, 65, 90, 85, 92, 88],
                   'rank':[10, 15, 21, 15, 20, 7, 6, 2]})
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Class</th>
      <th>Name</th>
      <th>Examination</th>
      <th>Subject</th>
      <th>Grade</th>
      <th>rank</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Mid</td>
      <td>Chinese</td>
      <td>80</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Final</td>
      <td>Chinese</td>
      <td>75</td>
      <td>15</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Mid</td>
      <td>Chinese</td>
      <td>85</td>
      <td>21</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Final</td>
      <td>Chinese</td>
      <td>65</td>
      <td>15</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Mid</td>
      <td>Math</td>
      <td>90</td>
      <td>20</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Final</td>
      <td>Math</td>
      <td>85</td>
      <td>7</td>
    </tr>
    <tr>
      <th>6</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Mid</td>
      <td>Math</td>
      <td>92</td>
      <td>6</td>
    </tr>
    <tr>
      <th>7</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Final</td>
      <td>Math</td>
      <td>88</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



これで、テストタイプと科目を組み合わせた4つのカテゴリ（中間語、期末語、中間数学、期末数学）をカラムインデックスに移動し、成績とランキングを同時にカウントします：



```python
pivot_multi = df.pivot(index = ['Class', 'Name'],
                       columns = ['Subject','Examination'],
                       values = ['Grade','rank'])
pivot_multi
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="4" halign="left">Grade</th>
      <th colspan="4" halign="left">rank</th>
    </tr>
    <tr>
      <th></th>
      <th>Subject</th>
      <th colspan="2" halign="left">Chinese</th>
      <th colspan="2" halign="left">Math</th>
      <th colspan="2" halign="left">Chinese</th>
      <th colspan="2" halign="left">Math</th>
    </tr>
    <tr>
      <th></th>
      <th>Examination</th>
      <th>Mid</th>
      <th>Final</th>
      <th>Mid</th>
      <th>Final</th>
      <th>Mid</th>
      <th>Final</th>
      <th>Mid</th>
      <th>Final</th>
    </tr>
    <tr>
      <th>Class</th>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <th>San Zhang</th>
      <td>80</td>
      <td>75</td>
      <td>90</td>
      <td>85</td>
      <td>10</td>
      <td>15</td>
      <td>20</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <th>Si Li</th>
      <td>85</td>
      <td>65</td>
      <td>92</td>
      <td>88</td>
      <td>21</td>
      <td>15</td>
      <td>6</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



新しいテーブルの行インデックスは、ユニーク性の原則に基づいて、 `index` 内の複数の列に対して `drop_duplicates` を使用することに相当します。カラムインデックスの長さは、 `values` 内の要素数に `columns` を乗じたユニークな組み合わせ数（ `index` と同様）です。対応する操作は、以下の模式図から比較的容易に理解できます：

<img src="../source/_static/ch5_mulpivot.png" width="35%">

### 2. pivot_table

 `pivot` の使用は一意性条件に依存しており、一意性条件が満たされない場合は、集約操作によって同じ行列の組み合わせに対応する複数の値を1つの値にする必要があります。例えば、張三と李四はいずれも国語試験と数学試験を2回受けたが、学院の規定によると、最後の成績は2回の試験点数の平均値であり、この時は `pivot` 関数では完成できない。



```python
df = pd.DataFrame({'Name':['San Zhang', 'San Zhang', 
                              'San Zhang', 'San Zhang',
                              'Si Li', 'Si Li', 'Si Li', 'Si Li'],
                   'Subject':['Chinese', 'Chinese', 'Math', 'Math',
                                 'Chinese', 'Chinese', 'Math', 'Math'],
                   'Grade':[80, 90, 100, 90, 70, 80, 85, 95]})
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Name</th>
      <th>Subject</th>
      <th>Grade</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>San Zhang</td>
      <td>Chinese</td>
      <td>80</td>
    </tr>
    <tr>
      <th>1</th>
      <td>San Zhang</td>
      <td>Chinese</td>
      <td>90</td>
    </tr>
    <tr>
      <th>2</th>
      <td>San Zhang</td>
      <td>Math</td>
      <td>100</td>
    </tr>
    <tr>
      <th>3</th>
      <td>San Zhang</td>
      <td>Math</td>
      <td>90</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Si Li</td>
      <td>Chinese</td>
      <td>70</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Si Li</td>
      <td>Chinese</td>
      <td>80</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Si Li</td>
      <td>Math</td>
      <td>85</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Si Li</td>
      <td>Math</td>
      <td>95</td>
    </tr>
  </tbody>
</table>
</div>



 `pivot_table` は `aggfunc` で実装され、 `aggfunc` 引数は使用される集約関数です。上記のシナリオは以下のように書くことができます。



```python
df.pivot_table(index = 'Name',
               columns = 'Subject',
               values = 'Grade',
               aggfunc = 'mean')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Subject</th>
      <th>Chinese</th>
      <th>Math</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>San Zhang</th>
      <td>85</td>
      <td>95</td>
    </tr>
    <tr>
      <th>Si Li</th>
      <td>75</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>



ここで `aggfunc` には、前章で説明したすべての合法的な集約文字列が含まれています。また、シーケンスを入力スカラーと出力とする集約関数を入力することでカスタム操作を実現することもできます。上記の機能は以下のように書くことができます：



```python
df.pivot_table(index = 'Name',
               columns = 'Subject',
               values = 'Grade',
               aggfunc = lambda x:x.mean())
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Subject</th>
      <th>Chinese</th>
      <th>Math</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>San Zhang</th>
      <td>85</td>
      <td>95</td>
    </tr>
    <tr>
      <th>Si Li</th>
      <td>75</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>



さらに、 `pivot_table` は、 `aggfunc` で示した集約方法と一致するように、 `margins=True` を設定することで実現することができる限界集約の機能を有する。以下に、国語の平均点と数学の平均点、張三の平均点と李四の平均点、そして全体のすべての点数の平均点をそれぞれ集計した：



```python
df.pivot_table(index = 'Name',
               columns = 'Subject',
               values = 'Grade',
               aggfunc='mean',
               margins=True)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Subject</th>
      <th>Chinese</th>
      <th>Math</th>
      <th>All</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>San Zhang</th>
      <td>85</td>
      <td>95.0</td>
      <td>90.00</td>
    </tr>
    <tr>
      <th>Si Li</th>
      <td>75</td>
      <td>90.0</td>
      <td>82.50</td>
    </tr>
    <tr>
      <th>All</th>
      <td>80</td>
      <td>92.5</td>
      <td>86.25</td>
    </tr>
  </tbody>
</table>
</div>



#### [練習して練習する]
上記の限界要約例では、行または列の要約は新しい表の行要素または列要素の平均値であり、全体の要約は新しい表の4つの要素の平均値である。この関係は必ず成り立っているのでしょうか？もし成立しない場合は、例を挙げて説明してください。
#### [END]
### 3. melt

長幅テーブルはデータの提示方式の違いに過ぎないが、それに含まれる情報量は等価であり、前述したように `pivot` を用いて長さテーブルをワイドテーブルに変えると、対応する逆操作でワイドテーブルをロングテーブルに変えることができ、 `melt` 関数はこのような役割を果たす。以下の例では、 `Subject` がカラムインデックスとして格納されていますが、それを1つのカラムに圧縮したいと思います。



```python
df = pd.DataFrame({'Class':[1,2],
                   'Name':['San Zhang', 'Si Li'],
                   'Chinese':[80, 90],
                   'Math':[80, 75]})
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Class</th>
      <th>Name</th>
      <th>Chinese</th>
      <th>Math</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>80</td>
      <td>80</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Si Li</td>
      <td>90</td>
      <td>75</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_melted = df.melt(id_vars = ['Class', 'Name'],
                    value_vars = ['Chinese', 'Math'],
                    var_name = 'Subject',
                    value_name = 'Grade')
df_melted
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Class</th>
      <th>Name</th>
      <th>Subject</th>
      <th>Grade</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Chinese</td>
      <td>80</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Chinese</td>
      <td>90</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Math</td>
      <td>80</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Math</td>
      <td>75</td>
    </tr>
  </tbody>
</table>
</div>



 `melt` の主なパラメータと圧縮のプロセスは次の図に示します：

<img src="../source/_static/ch5_melt.png" width="35%">

前述のように、 `melt` と `pivot` は相互逆プロセスのセットであるため、 `pivot` 操作によって `df_melted` を `df` の形式に戻すことができます。



```python
df_unmelted = df_melted.pivot(index = ['Class', 'Name'],
                              columns='Subject',
                              values='Grade')
df_unmelted # 下面需要恢复索引，并且重命名列索引名称
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Subject</th>
      <th>Chinese</th>
      <th>Math</th>
    </tr>
    <tr>
      <th>Class</th>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <th>San Zhang</th>
      <td>80</td>
      <td>80</td>
    </tr>
    <tr>
      <th>2</th>
      <th>Si Li</th>
      <td>90</td>
      <td>75</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_unmelted = df_unmelted.reset_index().rename_axis(columns={'Subject':''})
df_unmelted.equals(df)
```




    True



### 4. wide_to_long

 `melt` メソッドでは、カラムインデックスで圧縮された値のセットに対応するカラム要素は、同じ階層の意味のみを表すことができます。つまり `values_name`。現在、中間期末のカテゴリと国語数学のカテゴリなどの交差カテゴリが列に含まれている場合、 `values_name` に対応する `Grade` をそれぞれ国語点数と数学点数に対応する2つの列に拡張し、中間期末の情報だけを圧縮する必要がある場合は、 `wide_to_long` 関数を使用して行う必要があります。



```python
df = pd.DataFrame({'Class':[1,2],'Name':['San Zhang', 'Si Li'],
                   'Chinese_Mid':[80, 75], 'Math_Mid':[90, 85],
                   'Chinese_Final':[80, 75], 'Math_Final':[90, 85]})
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Class</th>
      <th>Name</th>
      <th>Chinese_Mid</th>
      <th>Math_Mid</th>
      <th>Chinese_Final</th>
      <th>Math_Final</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>80</td>
      <td>90</td>
      <td>80</td>
      <td>90</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Si Li</td>
      <td>75</td>
      <td>85</td>
      <td>75</td>
      <td>85</td>
    </tr>
  </tbody>
</table>
</div>





```python
pd.wide_to_long(df,
                stubnames=['Chinese', 'Math'],
                i = ['Class', 'Name'],
                j='Examination',
                sep='_',
                suffix='.+')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
      <th>Chinese</th>
      <th>Math</th>
    </tr>
    <tr>
      <th>Class</th>
      <th>Name</th>
      <th>Examination</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">1</th>
      <th rowspan="2" valign="top">San Zhang</th>
      <th>Mid</th>
      <td>80</td>
      <td>90</td>
    </tr>
    <tr>
      <th>Final</th>
      <td>80</td>
      <td>90</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">2</th>
      <th rowspan="2" valign="top">Si Li</th>
      <th>Mid</th>
      <td>75</td>
      <td>85</td>
    </tr>
    <tr>
      <th>Final</th>
      <td>75</td>
      <td>85</td>
    </tr>
  </tbody>
</table>
</div>



具体的な変換プロセスは次の図で示されています。同じ概念に属する要素は一致した色でマークされています：

<img src="../source/_static/ch5_wtl.png" width="35%">

以下では、以前の `pivot` セクションでの多列操作の結果（多段階インデックスが生成された）を、 `wide_to_long` 関数を用いて元の形態に変換する比較的複雑なケースを示します。このうち、第8章の `str.split` 関数が用いられており、今のところ、シーケンスをある区切り文字で分割すると理解すればよい。



```python
res = pivot_multi.copy()
res.columns = res.columns.map(lambda x:'_'.join(x))
res = res.reset_index()
res = pd.wide_to_long(res, stubnames=['Grade', 'rank'],
                           i = ['Class', 'Name'],
                           j = 'Subject_Examination',
                           sep = '_',
                           suffix = '.+')
res
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
      <th>Grade</th>
      <th>rank</th>
    </tr>
    <tr>
      <th>Class</th>
      <th>Name</th>
      <th>Subject_Examination</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">1</th>
      <th rowspan="4" valign="top">San Zhang</th>
      <th>Chinese_Mid</th>
      <td>80</td>
      <td>10</td>
    </tr>
    <tr>
      <th>Chinese_Final</th>
      <td>75</td>
      <td>15</td>
    </tr>
    <tr>
      <th>Math_Mid</th>
      <td>90</td>
      <td>20</td>
    </tr>
    <tr>
      <th>Math_Final</th>
      <td>85</td>
      <td>7</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">2</th>
      <th rowspan="4" valign="top">Si Li</th>
      <th>Chinese_Mid</th>
      <td>85</td>
      <td>21</td>
    </tr>
    <tr>
      <th>Chinese_Final</th>
      <td>65</td>
      <td>15</td>
    </tr>
    <tr>
      <th>Math_Mid</th>
      <td>92</td>
      <td>6</td>
    </tr>
    <tr>
      <th>Math_Final</th>
      <td>88</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>





```python
res = res.reset_index()
res[['Subject', 'Examination']] = res['Subject_Examination'].str.split('_', expand=True)
res = res[['Class', 'Name', 'Examination', 'Subject', 'Grade', 'rank']].sort_values('Subject')
res = res.reset_index(drop=True)
res
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Class</th>
      <th>Name</th>
      <th>Examination</th>
      <th>Subject</th>
      <th>Grade</th>
      <th>rank</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Mid</td>
      <td>Chinese</td>
      <td>80</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Final</td>
      <td>Chinese</td>
      <td>75</td>
      <td>15</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Mid</td>
      <td>Chinese</td>
      <td>85</td>
      <td>21</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Final</td>
      <td>Chinese</td>
      <td>65</td>
      <td>15</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Mid</td>
      <td>Math</td>
      <td>90</td>
      <td>20</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>Final</td>
      <td>Math</td>
      <td>85</td>
      <td>7</td>
    </tr>
    <tr>
      <th>6</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Mid</td>
      <td>Math</td>
      <td>92</td>
      <td>6</td>
    </tr>
    <tr>
      <th>7</th>
      <td>2</td>
      <td>Si Li</td>
      <td>Final</td>
      <td>Math</td>
      <td>88</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



## 2. 索引の変形

### 1. stackとunstack

第2章では `swaplevel` あるいは `reorder_levels` を用いたインデックス内のレイヤ交換について述べたが、以下では$\color {red} {行列インデックス間} $の交換について議論するが、この交換は `DataFrame` 次元の変化をもたらすため、変形操作である。第1節で述べた4つの変形関数は、それらがいずれもインデックス間の変換ではなく、$\color {red} {element} $と$\color {red} {column index} $の列または数列間の変換に属する点で異なる。

 `unstack` 関数の役割は、次の簡単な例のように、行のインデックスを列のインデックスに変換します。



```python
df = pd.DataFrame(np.ones((4,2)),
                  index = pd.Index([('A', 'cat', 'big'),
                                    ('A', 'dog', 'small'),
                                    ('B', 'cat', 'big'),
                                    ('B', 'dog', 'small')]),
                  columns=['col_1', 'col_2'])
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
      <th>col_1</th>
      <th>col_2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>cat</th>
      <th>big</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>dog</th>
      <th>small</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">B</th>
      <th>cat</th>
      <th>big</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>dog</th>
      <th>small</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>





```python
df.unstack()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">col_1</th>
      <th colspan="2" halign="left">col_2</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>big</th>
      <th>small</th>
      <th>big</th>
      <th>small</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>cat</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>dog</th>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">B</th>
      <th>cat</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>dog</th>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>



 `unstack` の主な引数は、移動するレイヤー番号です。デフォルトでは、最内側のレイヤーを変換し、カラムインデックスの最内側のレイヤーに移動し、複数のレイヤーを同時に変換することができます：



```python
df.unstack(2)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">col_1</th>
      <th colspan="2" halign="left">col_2</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>big</th>
      <th>small</th>
      <th>big</th>
      <th>small</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>cat</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>dog</th>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">B</th>
      <th>cat</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>dog</th>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>





```python
df.unstack([0,2])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="4" halign="left">col_1</th>
      <th colspan="4" halign="left">col_2</th>
    </tr>
    <tr>
      <th></th>
      <th colspan="2" halign="left">A</th>
      <th colspan="2" halign="left">B</th>
      <th colspan="2" halign="left">A</th>
      <th colspan="2" halign="left">B</th>
    </tr>
    <tr>
      <th></th>
      <th>big</th>
      <th>small</th>
      <th>big</th>
      <th>small</th>
      <th>big</th>
      <th>small</th>
      <th>big</th>
      <th>small</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>cat</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>dog</th>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>



 `pivot` のユニーク性要件と同様に、 `unstack` では、$\color {red} {列インデックスに変更された行インデックスレイヤー} $と$\color {red} {保持された行インデックスレイヤー} $の組み合わせがユニークであることを保証しなければなりません。例えば、最初の2つの列インデックスを同じに変更してユニーク性を破壊すると、エラーが報告されます。



```python
my_index = df.index.to_list()
my_index[1] = my_index[0]
df.index = pd.Index(my_index)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
      <th>col_1</th>
      <th>col_2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th rowspan="2" valign="top">cat</th>
      <th>big</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>big</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">B</th>
      <th>cat</th>
      <th>big</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>dog</th>
      <th>small</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>





```python
try:
    df.unstack()
except Exception as e:
    Err_Msg = e
Err_Msg
```




    ValueError('Index contains duplicate entries, cannot reshape')



 `unstack` とは対照的に、 `stack` の役割は、列のインデックスを行のインデックスにラミネートすることであり、これはまったく同じように使われます。



```python
df = pd.DataFrame(np.ones((4,2)),
                  index = pd.Index([('A', 'cat', 'big'),
                                    ('A', 'dog', 'small'),
                                    ('B', 'cat', 'big'),
                                    ('B', 'dog', 'small')]),
                  columns=['index_1', 'index_2']).T
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="2" halign="left">A</th>
      <th colspan="2" halign="left">B</th>
    </tr>
    <tr>
      <th></th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th></th>
      <th>big</th>
      <th>small</th>
      <th>big</th>
      <th>small</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>index_1</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>index_2</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>





```python
df.stack()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">A</th>
      <th colspan="2" halign="left">B</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">index_1</th>
      <th>big</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>small</th>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">index_2</th>
      <th>big</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>small</th>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>





```python
df.stack([1, 2])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">index_1</th>
      <th>cat</th>
      <th>big</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>dog</th>
      <th>small</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">index_2</th>
      <th>cat</th>
      <th>big</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>dog</th>
      <th>small</th>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>



### 2. 集合と変形の関係

上記のすべての関数のうち、集約効果を持つ `pivot_table` を除いて、すべての関数は変形前と後で `values` の数に変化をもたらすことはありません。ただこれらの値の提示形式が変化します。前章で議論したグループ集約操作も、新しい行列インデックスが生成されるため、必然的に何らかの特殊な変形操作に属するが、集約後に元の複数の値が1つの値に変化するため、 `values` の個数が変化し、これもグループ集約と変形関数の最大の違いである。

## 3. その他の変形関数

### 1. crosstab

 `crosstab` は、 `pivot_table` ができるすべての机能を実行できるため、不快な関数です。デフォルトでは、 `crosstab` 要素の組み合わせの頻度をカウントできます。つまり、 `count` 操作です。たとえば、 `learn_pandas` データセットの学校と学部転換の頻度を集計します：



```python
df = pd.read_csv('../data/learn_pandas.csv')
pd.crosstab(index = df.School, columns = df.Transfer)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Transfer</th>
      <th>N</th>
      <th>Y</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Fudan University</th>
      <td>38</td>
      <td>1</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <td>28</td>
      <td>2</td>
    </tr>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <td>53</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Tsinghua University</th>
      <td>62</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



これは次のように `crosstab` を書くことと同じです。ここでは、 `aggfunc` は集約パラメータです。



```python
pd.crosstab(index = df.School, columns = df.Transfer, values = [0]*df.shape[0], aggfunc = 'count')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Transfer</th>
      <th>N</th>
      <th>Y</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Fudan University</th>
      <td>38.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <td>28.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <td>53.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Tsinghua University</th>
      <td>62.0</td>
      <td>4.0</td>
    </tr>
  </tbody>
</table>
</div>



同様に、 `pivot_table` を使用して同等の操作を行うことができます。ここでは、組み合わせの頻度を集計するため、 `values` パラメータがどの列に渡されても、最終的な結果に影響を与えません。



```python
df.pivot_table(index = 'School',
               columns = 'Transfer',
               values = 'Name',
               aggfunc = 'count')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Transfer</th>
      <th>N</th>
      <th>Y</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Fudan University</th>
      <td>38.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <td>28.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <td>53.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Tsinghua University</th>
      <td>62.0</td>
      <td>4.0</td>
    </tr>
  </tbody>
</table>
</div>



上記から分かるように、この2つの関数の違いは、 `crosstab` の対応する位置には具体的なシーケンスが入力され、 `pivot_table` には呼び出されたテーブルに対応する名前が入力され、シーケンスに対応する値が入力されるとエラーが報告されることである。

デフォルトの `count` 統計を除いて、集約文字列とスカラーを返すカスタム関数はすべて利用できます。たとえば、組み合わせの平均身長の統計などです：



```python
pd.crosstab(index = df.School, columns = df.Transfer, values = df.Height, aggfunc = 'mean')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Transfer</th>
      <th>N</th>
      <th>Y</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Fudan University</th>
      <td>162.043750</td>
      <td>177.20</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <td>163.429630</td>
      <td>162.40</td>
    </tr>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <td>163.953846</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Tsinghua University</th>
      <td>163.253571</td>
      <td>164.55</td>
    </tr>
  </tbody>
</table>
</div>



### 2. explode

 `explode` パラメータは、列の要素を縦方向に展開することができます。展開されるセルには、 `list, tuple, Series, np.ndarray` のタイプが格納されている必要があります。



```python
df_ex = pd.DataFrame({'A': [[1, 2], 'my_str', {1, 2}, pd.Series([3, 4])],
                      'B': 1})
df_ex
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>[1, 2]</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>my_str</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>{1, 2}</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0    3
1    4
dtype: int64</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>





```python
df_ex.explode('A')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0</th>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>my_str</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



### 3. get_dummies

 `get_dummies` はフィーチャー構築のための重要な関数の1つであり、その役割はカテゴリフィーチャーをインジケータ変数に変換することである。たとえば、学年列を指示変数に変更すると、1つの学年に属する対応する列には1、それ以外の場合は0になります：



```python
pd.get_dummies(df.Grade).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Freshman</th>
      <th>Junior</th>
      <th>Senior</th>
      <th>Sophomore</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



## 四、練習
### Ex1：米国の違法薬物データセット

米国の違法薬物に関するデータセットがあり、 `SubstanceName, DrugReports` はそれぞれ薬物名と報告された数を示しています：



```python
df = pd.read_csv('../data/drugs.csv').sort_values(['State','COUNTY','SubstanceName'],ignore_index=True)
df.head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>YYYY</th>
      <th>State</th>
      <th>COUNTY</th>
      <th>SubstanceName</th>
      <th>DrugReports</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2011</td>
      <td>KY</td>
      <td>ADAIR</td>
      <td>Buprenorphine</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2012</td>
      <td>KY</td>
      <td>ADAIR</td>
      <td>Buprenorphine</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2013</td>
      <td>KY</td>
      <td>ADAIR</td>
      <td>Buprenorphine</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



1. データを次の形式に変換します：

<img src="../source/_static/Ex5_1.png" width="35%">

2. 第1問の結果を元の表に戻す。
3. 毎年のレポート数の合計を `State` 別に集計します。ここで、 `State, YYYY` はそれぞれカラムインデックスとローインデックスです。 `pivot_table` 関数と `groupby+unstack` という2つの異なるポリシーを実装し、それらの間の関係を理解する必要があります。

### Ex2：特別なwide_to_longメソッド

机能的には、 `melt` メソッドは `wide_to_long` の特別なケースに属しているはずです。つまり、 `stubnames` は1つのクラスのみです。 `wide_to_long` 生成 `melt` セクションの `df_melted` を使用してください。（ヒント：カラム名に適切な接頭辞を付ける）



```python
df = pd.DataFrame({'Class':[1,2],
                   'Name':['San Zhang', 'Si Li'],
                   'Chinese':[80, 90],
                   'Math':[80, 75]})
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Class</th>
      <th>Name</th>
      <th>Chinese</th>
      <th>Math</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>San Zhang</td>
      <td>80</td>
      <td>80</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Si Li</td>
      <td>90</td>
      <td>75</td>
    </tr>
  </tbody>
</table>
</div>


